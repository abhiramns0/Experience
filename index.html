<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Portfolio Homepage</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000214; /* fallback */
    }
    canvas {
      position: fixed;
      inset: 0;
      z-index: -1;
    }
    .content {
      position: relative;
      z-index: 1;
      color: white;
      text-align: center;
      padding: 20%;
      font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div class="content">
    <h1>Welcome to My Portfolio</h1>
    <p>Designer showcasing futuristic tech vibes.</p>
  </div>

  <script>
    /* =========================
       CONFIG: Visual + Physics
       ========================= */
    // Particles
    const NUM_PARTICLES = 150;
    const PARTICLE_SIZE_MIN = 1;
    const PARTICLE_SIZE_MAX = 3;
    const PARTICLE_SPEED = 0.1;
    const CONNECTION_DISTANCE = 150;
    const MOUSE_CONNECTION_DISTANCE = 200;
    const REPEL_DISTANCE = 150;
    const REPEL_STRENGTH = 1.0;
    const GLOW_BLUR = 14;
    const LINE_WIDTH = 0.8;
    const SPRING_STRENGTH = 0.005;
    const DAMPING = 0.95;

    // Bokeh (ambient blobs)
    const NUM_BOKEH = 30;
    const BOKEH_SIZE_MIN = 8;   // bigger for presence
    const BOKEH_SIZE_MAX = 38;
    const BOKEH_OPACITY_MIN = 0.06;
    const BOKEH_OPACITY_MAX = 0.22;
    const BOKEH_SPEED = 0.04;   // very slow drift
    const BOKEH_BLUR_MIN = 6;   // px
    const BOKEH_BLUR_MAX = 22;  // px

    // Colors
    const BASE_DARK = '#000214';        // outer edge
    const MID_DARK  = '#00112a';        // mid ring
    const CENTER_LIGHT = '#042b53';     // center tint (still dark overall)
    const DOT_COLOR = '173, 216, 230';  // light-blue-ish (RGB)

    // Gradient center (as % of canvas) & radius factor
    let GRADIENT_CX = 0.5; // center x (0..1)
    let GRADIENT_CY = 0.4; // center y (0..1) slightly above center
    let GRADIENT_RADIUS = 1.05; // relative to max(canvas.width, canvas.height)

    /* =========================
       CONFIG: Density Regions
       =========================
       Weighted spawn regions so you can steer where particles are denser.

       Types supported:
       - type: 'rect'  with {x, y, w, h} in normalized units (0..1), weight > 0
       - type: 'band'  (diagonal band) with {from:[x,y], to:[x,y], radius: px|rel, weight}
                       radius can be:
                         - number (pixels), or
                         - { rel: number } -> relative to min(canvas dim)
    */
    const BASE_DENSITY = 0.15; // baseline acceptance probability (0..1)

    const DENSITY_REGIONS = [
      // Default diagonal band: bottom-left â†’ top-right
      {
        type: 'band',
        from: [0.0, 1.0],
        to:   [1.0, 0.0],
        radius: { rel: 0.08 }, // ~8% of the min dimension
        weight: 0.75            // add to acceptance probability
      },
      // Example extra rectangle hotspot (uncomment to use):
      // {
      //   type: 'rect',
      //   x: 0.1, y: 0.65, w: 0.25, h: 0.25,
      //   weight: 0.5
      // }
    ];

    // Utility to resolve a radius which may be px or relative
    function resolveRadius(rad, w, h) {
      if (typeof rad === 'number') return rad;
      if (rad && typeof rad.rel === 'number') {
        return Math.min(w, h) * rad.rel;
      }
      return 0;
    }

    // Compute density weight at a pixel coordinate
    function densityAt(x, y, w, h) {
      let p = BASE_DENSITY; // start from baseline
      for (const r of DENSITY_REGIONS) {
        if (r.type === 'rect') {
          const rx = r.x * w, ry = r.y * h, rw = r.w * w, rh = r.h * h;
          if (x >= rx && x <= rx + rw && y >= ry && y <= ry + rh) {
            p += r.weight;
          }
        } else if (r.type === 'band') {
          const x1 = r.from[0] * w, y1 = r.from[1] * h;
          const x2 = r.to[0]   * w, y2 = r.to[1]   * h;
          const rad = resolveRadius(r.radius, w, h);
          const dist = pointToSegmentDistance(x, y, x1, y1, x2, y2);
          if (dist <= rad) {
            // fade weight by proximity to band center
            const t = 1 - (dist / rad);
            p += r.weight * t;
          }
        }
      }
      // clamp 0..1 for acceptance
      return Math.max(0, Math.min(1, p));
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx*dx + dy*dy || 1e-6;
      let t = ((px - x1) * dx + (py - y1) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const sx = x1 + t * dx, sy = y1 + t * dy;
      const ddx = px - sx, ddy = py - sy;
      return Math.hypot(ddx, ddy);
    }

    // Rejection sampling that honors density regions
    function sampleWeightedPosition(w, h, maxTries = 500) {
      for (let i = 0; i < maxTries; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        const accept = Math.random() < densityAt(x, y, w, h);
        if (accept) return { x, y };
      }
      // Fallback (uniform) if we somehow failed
      return { x: Math.random() * w, y: Math.random() * h };
    }

    /* =========================
       Canvas + Resize
       ========================= */
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2); // cap for perf
      const { innerWidth: w, innerHeight: h } = window;
      canvas.style.width  = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width  = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // reset scale for drawing in CSS pixels
      // Re-home particles to preserve layout after resize
      particles.forEach(p => {
        p.homeX = Math.random() * w;
        p.homeY = Math.random() * h;
      });
      bokehParticles.forEach(p => {
        p.homeX = Math.random() * w;
        p.homeY = Math.random() * h;
      });
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    /* =========================
       Particles
       ========================= */
    class Particle {
      constructor(isBokeh = false) {
        const { innerWidth: w, innerHeight: h } = window;
        const pos = sampleWeightedPosition(w, h);

        this.x = pos.x;
        this.y = pos.y;
        this.homeX = this.x;
        this.homeY = this.y;

        this.isBokeh = isBokeh;

        const spd = isBokeh ? BOKEH_SPEED : PARTICLE_SPEED;
        this.vx = (Math.random() - 0.5) * spd;
        this.vy = (Math.random() - 0.5) * spd;

        if (isBokeh) {
          this.size = randBetween(BOKEH_SIZE_MIN, BOKEH_SIZE_MAX);
          this.opacity = randBetween(BOKEH_OPACITY_MIN, BOKEH_OPACITY_MAX);
          this.blur = randBetween(BOKEH_BLUR_MIN, BOKEH_BLUR_MAX);
        } else {
          this.size = randBetween(PARTICLE_SIZE_MIN, PARTICLE_SIZE_MAX);
          this.opacity = 0.8 + Math.random() * 0.2;
          this.blur = GLOW_BLUR;
        }
      }

      update() {
        const springX = (this.homeX - this.x) * SPRING_STRENGTH;
        const springY = (this.homeY - this.y) * SPRING_STRENGTH;
        this.vx += springX;
        this.vy += springY;

        this.vx *= DAMPING;
        this.vy *= DAMPING;

        this.x += this.vx;
        this.y += this.vy;

        const w = window.innerWidth;
        const h = window.innerHeight;
        if (this.x < 0 || this.x > w) this.vx *= -1;
        if (this.y < 0 || this.y > h) this.vy *= -1;
      }

      draw() {
        if (this.isBokeh) {
          // Heavier blur for bokeh + subtle glow
          ctx.save();
          ctx.filter = `blur(${this.blur}px)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${DOT_COLOR}, ${this.opacity})`;
          ctx.shadowColor = `rgba(${DOT_COLOR}, ${Math.min(0.6, this.opacity + 0.1)})`;
          ctx.shadowBlur = this.blur * 0.6;
          ctx.fill();
          ctx.restore();
        } else {
          // Crisp dot with glow
          ctx.save();
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${DOT_COLOR}, ${this.opacity})`;
          ctx.shadowColor = `rgba(${DOT_COLOR}, 0.8)`;
          ctx.shadowBlur = this.blur;
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function randBetween(a, b) { return a + Math.random() * (b - a); }

    const particles = Array.from({ length: NUM_PARTICLES }, () => new Particle(false));
    const bokehParticles = Array.from({ length: NUM_BOKEH }, () => new Particle(true));

    /* =========================
       Input
       ========================= */
    let mouse = { x: undefined, y: undefined };

    window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = mouse.y = undefined; });

    window.addEventListener('touchmove', (e) => {
      if (e.touches.length) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      }
    }, { passive: true });
    window.addEventListener('touchend', () => { mouse.x = mouse.y = undefined; });

    /* =========================
       Render
       ========================= */
    function drawRadialGradient() {
      const w = window.innerWidth, h = window.innerHeight;
      const cx = w * GRADIENT_CX, cy = h * GRADIENT_CY;
      const maxR = Math.max(w, h) * GRADIENT_RADIUS;

      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
      grad.addColorStop(0.0, CENTER_LIGHT);
      grad.addColorStop(0.55, MID_DARK);
      grad.addColorStop(1.0, BASE_DARK);

      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Dark radial gradient background
      drawRadialGradient();

      // Background bokeh first
      for (const b of bokehParticles) {
        b.update();
        b.draw();
      }

      // Web connections (light lines)
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const a = particles[i], b = particles[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < CONNECTION_DISTANCE) {
            const opacity = (1 - dist / CONNECTION_DISTANCE) * 0.5;
            ctx.strokeStyle = `rgba(${DOT_COLOR}, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }

      // Foreground particles
      for (const p of particles) {
        p.update();
        p.draw();
      }

      // Interactions
      if (mouse.x !== undefined && mouse.y !== undefined) {
        for (const p of particles) {
          const dx = p.x - mouse.x, dy = p.y - mouse.y;
          const dist = Math.hypot(dx, dy);
          if (dist < REPEL_DISTANCE && dist > 0) {
            const force = (1 - dist / REPEL_DISTANCE) * REPEL_STRENGTH;
            const ang = Math.atan2(dy, dx);
            p.vx += Math.cos(ang) * force;
            p.vy += Math.sin(ang) * force;
          }
        }
        for (const p of particles) {
          const dx = p.x - mouse.x, dy = p.y - mouse.y;
          const dist = Math.hypot(dx, dy);
          if (dist < MOUSE_CONNECTION_DISTANCE) {
            const opacity = (1 - dist / MOUSE_CONNECTION_DISTANCE) * 0.8;
            ctx.strokeStyle = `rgba(${DOT_COLOR}, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();
          }
        }
      }
    }

    animate();
  </script>
</body>
</html>
